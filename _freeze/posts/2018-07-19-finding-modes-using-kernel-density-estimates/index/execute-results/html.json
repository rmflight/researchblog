{
  "hash": "18f832103644d3d59dcd70f8abd5c30f",
  "result": {
    "markdown": "---\ntitle: \"Finding Modes Using Kernel Density Estimates\"\ndate: '2018-07-19'\ncategories: [R, python, kernel-density, pdf, probability-density, programming]\nsubtitle: |\n  Examples of finding the mode of a univeriate distribution in R and Python.\n---\n\n\n## TL; DR\n\nIf you have a unimodal distribution of values, you can use R's `density` or\nScipy's `gaussian_kde` to create density estimates of the data, and then\ntake the maxima of the density estimate to get the `mode`. See below for\nactual examples in R and Python.\n\n\n## Mode in R\n\nFirst, lets do this in R. Need some values to work with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nset.seed(1234)\nn_point <- 1000\ndata_df <- data.frame(values = rnorm(n_point))\n\nggplot(data_df, aes(x = values)) + geom_histogram()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/density_mode-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data_df, aes(x = values)) + geom_density()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/density_mode-2.png){width=672}\n:::\n:::\n\n\nWe can do a kernel density, which will return an object with a bunch of peices.\nOne of these is `y`, which is the actual density value for each value of `x` that was used! So\nwe can find the `mode` by querying `x` for the maxima in `y`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity_estimate <- density(data_df$values)\n\nmode_value <- density_estimate$x[which.max(density_estimate$y)]\nmode_value\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.04599328\n```\n:::\n:::\n\n\nPlot the density estimate with the mode location.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndensity_df <- data.frame(value = density_estimate$x, density = density_estimate$y)\n\nggplot(density_df, aes(x = value, y = density)) + geom_line() + geom_vline(xintercept = mode_value, color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_density-1.png){width=672}\n:::\n:::\n\n\n## Python\n\nLets do something similar in Python. Start by generating a set of random values.\n\n\n::: {.cell engine.path='/usr/bin/python3'}\n\n```{.python .cell-code}\nimport numpy as np\nimport scipy.stats as stats\nimport matplotlib.pyplot as plt\n\nvalues = np.random.normal(size = 1000)\n\nplt.hist(values)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(array([  1.,   7.,  44., 105., 217., 296., 207.,  87.,  27.,   9.]), array([-3.80368902, -3.10698209, -2.41027516, -1.71356823, -1.01686129,\n       -0.32015436,  0.37655257,  1.07325951,  1.76996644,  2.46667337,\n        3.16338031]), <BarContainer object of 10 artists>)\n```\n:::\n\n```{.python .cell-code}\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\nAnd then use `gaussian_kde` to get a kernel estimator of the density, and then\ncall the `pdf` method on the original values.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nkernel = stats.gaussian_kde(values)\nheight = kernel.pdf(values)\n\nmode_value = values[np.argmax(height)]\nprint(mode_value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-0.08045792953113866\n```\n:::\n:::\n\n\nPlot to show indeed we have it right. Note we sort the values first so the PDF\nlooks right.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvalues2 = np.sort(values.copy())\nheight2 = kernel.pdf(values2)\n\nplt.clf()\nplt.cla()\nplt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<string>:1: MatplotlibDeprecationWarning: The close_event function was deprecated in Matplotlib 3.6 and will be removed two minor releases later. Use callbacks.process('close_event', CloseEvent(...)) instead.\n```\n:::\n\n```{.python .cell-code}\nplt.plot(values2, height2)\nplt.axvline(mode_value)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}