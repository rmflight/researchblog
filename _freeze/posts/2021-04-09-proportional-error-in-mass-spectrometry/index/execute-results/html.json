{
  "hash": "24d9e0005820921e91c4fa99a2e20902",
  "result": {
    "markdown": "---\ntitle: \"Proportional Error in Mass Spectrometry\"\nsubtitle: |\n  Demonstrating the existence of proportional error in mass spectrometry measurements.\ndate: 04-09-2021\nbibliography: refs.bib\ncategories: [mass-spectrometry, proportional-error, omics, metabolomics]\n---\n\n\n\n\n## Introduction\n\nThe other day, Kareem Carr asked for a statistics / data science opinion that results in the daggers being drawn on you [@kareem2021], and I replied [@flight2021]:\n\n> Every physical analytical measurement in -omics suffers from some proportional error. Either model it (neg binomial in RNA-seq for example), or transform your data appropriately (log-transform).\n>\n> This includes DNA microarrays, RNA-seq, Mass Spec, and NMR (I need data to confirm)\n\nI wanted to give some proof of what I'm talking about, because I don't think enough people understand or care.\nFor example, if you get mass-spec data from Metabolon, their Surveyor tool defaults to using non-log-transformed data.\nTrust me, you should log-transform the values.\n\n## Example Data\n\nI have some direct-injection mass spec data on a polar fraction examining ECF derivatized amino-acids, with multiple \"scans\" from a Thermo Fisher Fusion Tribrid Mass Spectrometer.\nEach scan is the product of a small number of micro-scans.\nHowever, based on the spectrometer, and the lack of chromatography, it would not be unreasonable to expect that each scan is essentially a \"replicate\" of the other scans, so comparing one to any other is reasonable.\n\nI'm going to load up the data, and plot two scans in \"raw\" space.\nThe data are already log10 transformed, so we will \"untransform\" it back to \"raw\" first before plotting it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(dplyr)\nscan_data = readRDS(here::here(\"data_files/mass_spec_example_data.rds\"))\nraw_data = purrr::map_dfc(scan_data, ~ 10^.x)\n\nraw_data %>%\n  dplyr::filter(scan174 <= 1e7) %>%\nggplot(aes(x = scan174, y = scan175)) + \n  geom_point() +\n  coord_equal() +\n  labs(subtitle = \"Scan-Scan Intensities, Raw Values\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/load_data-1.png){width=672}\n:::\n:::\n\n\nAs you can see here, the points *really* start to diverge as they cross the line at 2.5 x 10^6.\n\nNow lets plot the log10 transformed values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscan_data %>%\n  dplyr::filter(scan174 <= 1e7) %>%\nggplot(aes(x = scan174, y = scan175)) + \n  geom_point() +\n  coord_equal() +\n  labs(subtitle = \"Scan-Scan Intensities, Log10 Values\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/plot_log-1.png){width=672}\n:::\n:::\n\nAnd now everything is coming to a point as the intensity increases.\n\nIf you've worked with microarray or RNASeq data, this is also commonly seen in those data.\n\nTo show the presence of the proportional error more generally, we can calculate the mean and variance of each point across the scans, and plot those.\nTo make sure we are getting \"good\" representations of the data, we will only use points that were present in at least 20 scans.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoint_mean = rowMeans(raw_data, na.rm = TRUE)\npoint_sd = apply(raw_data, 1, sd, na.rm = TRUE)\nn_present = apply(raw_data, 1, function(.x){sum(!is.na(.x))})\n\nmean_sd = data.frame(mean = point_mean,\n                     sd = point_sd,\n                     n = n_present)\nmean_sd %>%\n  dplyr::filter(n >= 20) %>%\n  ggplot(aes(x = mean, y = sd)) + geom_point() +\n  labs(subtitle = \"Standard Deviation vs Mean\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/calculate_mean_sd-1.png){width=672}\n:::\n:::\n\n\nThere you have it, the standard deviation is increasing with the mean, and doing so in two different ways, one increasing slowly, and one increasing quickly.\nEither of these are not good.\nWhether increasing slowly or quickly, the point is that the error / variance / standard deviation is somehow dependent on the mean, which most standard statistical methods *do not* handle well.\nThis actually drove the whole development of using the negative-binomial distribution in RNASeq!\n\n## Why??\n\nWhy does this happen?\nTry this thought experiment:\n\n* I take 5 people in a room, and ask you to count how many people are in the room in 60 seconds and give me an answer.\n* I ask you to do this 20 times.\n* Your answer should be 5 each time, right?\n* Now I put 10 people in the room, and ask again how many are there. And ask multiple times.\n* Now 20 people in the same size room.\n* And then 30 people ...\n* And then 40 people ...\n* And so on.\n\nIf you think about it, given an constantly sized room, it will get harder and harder to count the people in it as their number increases, and with repeated counting, your estimates are likely to have more and more variance or a higher standard deviation as the number of people goes up.\nThus the \"error\" is proportional or depends on the actual number of things you are estimating, much like the mass spec data above.\n\nIn DNA microarrays and RNA-seq, the technology was measuring photons.\nThe higher the number of photons, the more difficult it is to be sure how many there are.\nAnd that gets translated to any downstream quantity based on the number of photons.\n\nIn Fourier-transform mass spectrometry, the instrument is still trying to quantify \"how many\" of each ion there is, and the more ions, the more difficult it is to quantify them.\nAnd we end up with proportional error.\n\nI think in any technology that is trying to \"count\" how many of something there is within a finite space, these properties will manifest themselves.\nYou just have to know how to look.\n\n## Solution\n\nIn the short term, transform your data using log's.\nIn the long term, I think we need more biostatisticians working with more mass-spectrometry and NMR data to determine what the error structure is for more instruments and analytical measurement types.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}