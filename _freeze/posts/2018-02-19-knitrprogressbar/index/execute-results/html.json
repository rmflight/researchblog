{
  "hash": "f144cd4526abbcbbf1c2f83953af3540",
  "result": {
    "markdown": "---\ntitle: \"knitrProgressBar Package\"\ndate: '2018-02-19'\ncategories: [packages, R, developement]\nsubtitle: |\n  Ever wanted a progress bar output visible in a knitr document? Now you can!\n---\n\n\n## TL;DR\n\nIf you like `dplyr` progress bars, and wished you could use them everywhere, including from within Rmd documents, non-interactive shells, etc, then you should check out `knitrProgressBar` ([cran](https://cran.r-project.org/package=knitrProgressBar) [github](https://github.com/rmflight/knitrProgressBar)).\n\n## Why Yet Another Progress Bar??\n\nI didn't set out to create **another** progress bar package. But I really liked `dplyr`s style of progress bar, and how they worked under the hood (thanks to the [examples](https://rud.is/b/2017/03/27/all-in-on-r%E2%81%B4-progress-bars-on-first-post/) from Bob Rudis).\n\nAs I used them, I noticed that no progress was displayed if you did `rmarkdown::render()` or `knitr::knit()`. That just didn't seem right to me, as that means you get no progress indicator if you want to use caching facilities of `knitr`. So this package was born.\n\n## How??\n\nThese are pretty easy to setup and use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(knitrProgressBar)\n\n# borrowed from example by @hrbrmstr\narduously_long_nchar <- function(input_var, .pb=NULL) {\n  \n  update_progress(.pb) # function from knitrProgressBar\n  \n  Sys.sleep(0.01)\n  \n  nchar(input_var)\n  \n}\n\n# using stdout() here so progress is part of document\npb <- progress_estimated(26, progress_location = stdout())\n\npurrr::map(letters, arduously_long_nchar, .pb = pb)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n|======                                                | 12% ~0 s remaining     \n|================                                      | 31% ~0 s remaining     \n|===========================                           | 50% ~0 s remaining     \n|=====================================                 | 69% ~0 s remaining     \n|===============================================       | 88% ~0 s remaining     \nCompleted after 0 s                                                             \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] 1\n\n[[4]]\n[1] 1\n\n[[5]]\n[1] 1\n\n[[6]]\n[1] 1\n\n[[7]]\n[1] 1\n\n[[8]]\n[1] 1\n\n[[9]]\n[1] 1\n\n[[10]]\n[1] 1\n\n[[11]]\n[1] 1\n\n[[12]]\n[1] 1\n\n[[13]]\n[1] 1\n\n[[14]]\n[1] 1\n\n[[15]]\n[1] 1\n\n[[16]]\n[1] 1\n\n[[17]]\n[1] 1\n\n[[18]]\n[1] 1\n\n[[19]]\n[1] 1\n\n[[20]]\n[1] 1\n\n[[21]]\n[1] 1\n\n[[22]]\n[1] 1\n\n[[23]]\n[1] 1\n\n[[24]]\n[1] 1\n\n[[25]]\n[1] 1\n\n[[26]]\n[1] 1\n```\n:::\n:::\n\n\nThe main difference to `dplyr`s progress bars is that here you have the option to set **where** the progress gets written to, either automatically using the built-in `make_kpb_output_decisions()`, or directly. Also, I have provided the `update_progress` function to actually do the updating or finalizing properly.\n\nThere are also package specific options to control **how** the decisions are made.\n\nSee the [main](https://rmflight.github.io/knitrProgressBar/) documentation, as well as the [included vignette](https://rmflight.github.io/knitrProgressBar/articles/example_progress_bars.html).\n\n## Multi-Processing\n\nAs of V1.1.0 (should be on CRAN soon), the package also supports indicating progress on multi-processed jobs. See the included [vignette](https://rmflight.github.io/knitrProgressBar/articles/multiprocessing.html) for more information.\n\nBy the way, I know this method is not ideal, but I could not get the combination of `later` and `processx` to work in my case. If anyone is willing to help out, that would be great.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}