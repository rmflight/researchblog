{
  "hash": "95bee07b183cde176143e8531b369ca5",
  "result": {
    "markdown": "---\ntitle: \"Comparisons using for loops vs split\"\ndate: '2019-02-13'\ncategories: [R, for-loop, split, purrr, development]\nsubtitle: |\n  for loops often hide much of the actual logic of your code because of all the necessary boilerplate of running a loop. split-ting your data can oftentimes be clearer, and faster.\n---\n\n\n## TL;DR\n\nSometimes `for` loops are useful, and sometimes they shouldn't really be used, because they don't really help you understand your data, and even if you try, they\nmight still be slow(er) than other ways of doing things.\n\n## Comparing Groups\n\nI have some code where I am trying to determine duplicates of a **group** of things. This data looks something like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_random_sets = function(n_sets = 1000){\n  set.seed(1234)\n  \n  sets = purrr::map(seq(5, n_sets), ~ sample(seq(1, .x), 5))\n  \n  item_sets = sample(seq(1, length(sets)), 10000, replace = TRUE)\n  item_mapping = purrr::map2_df(item_sets, seq(1, length(item_sets)), function(.x, .y){\n    data.frame(v1 = as.character(.y), v2 = sets[[.x]], stringsAsFactors = FALSE)\n  })\n  item_mapping\n}\nlibrary(dplyr)\nmapped_items = create_random_sets()\n\nhead(mapped_items, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   v1  v2\n1   1 375\n2   1 255\n3   1 268\n4   1  52\n5   1 241\n6   2 143\n7   2 401\n8   2 127\n9   2 372\n10  2 100\n11  3  62\n12  3 109\n13  3  72\n14  3 390\n15  3  94\n16  4  57\n17  4  55\n18  4 147\n19  4 236\n20  4 120\n```\n:::\n:::\n\n\n## Looping\n\nIn this case, every `item` in `v1` has **5** things in `v2`. I really want to group multiple things of `v1` that have the same combination of things in `v2`. My initial function\nto do this `split`s everything in `v2` by `v1`, and then compares all the splits to each other, removing things that have been compared and found to be the same, and saving them \nas we go. This required two loops, basically `while` there was data to check, check all the other things left in the list against it (the `for`).\nPre-initialize the list of things that are identical to each other so we don't take a hit on allocation, and delete the things that have been checked or noted as identical. Although the variable names are changed, the code for that function is below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nloop_function = function(item_mapping){\n  split_items = split(item_mapping$v2, item_mapping$v1)\n  \n  matched_list = vector(\"list\", length(split_items))\n  \n  save_item = 1\n  save_index = 1\n  \n  while (length(split_items) > 0) {\n    curr_item = names(split_items)[save_item]\n    curr_set = split_items[[save_item]]\n    \n    for (i_item in seq_along(split_items)) {\n      if (sum(split_items[[i_item]] %in% curr_set) == length(curr_set)) {\n        matching_items = unique(c(curr_item, names(split_items)[i_item]))\n        save_item = unique(c(save_item, i_item))\n      }\n    }\n    matched_list[[save_index]] = curr_set\n    split_items = split_items[-save_item]\n    save_index = save_index + 1\n    save_item = 1\n  }\n  \n  n_in_set = purrr::map_int(matched_list, length)\n  matched_list = matched_list[n_in_set > 0]\n  n_in_set = n_in_set[n_in_set > 0]\n  matched_list\n}\n```\n:::\n\n\nThe code works, but it doesn't really make me **think** about what it's doing, the two loops hide the fact that what is really going on is **comparing** things to one another. \nMiles McBain [recently posted](https://milesmcbain.xyz/for-loops/) on this fact, that loops can be necessary, but one should really think about whether they are really necessary,\nor do they hide something about the data, and can we think about different ways to do the same thing.\n\nThis made me realize that what I really wanted to do was `split` the items in `v1` by the unique combinations of things in `v2`, because `split` will group things together nicely\nfor you, without any extra work. But I don't have those combinations in a way that `split` can use them. So my solution is to iterate over the splits using `purrr`, \ncreate a representation of the group as a character value, and then call `split` again at the very end based on the `character` representation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsplit_function = function(item_mapping){\n  mapped_data = split(item_mapping$v2, item_mapping$v1) %>%\n    purrr::map2_dfr(., names(.), function(.x, .y){\n      set = unique(.x)\n      tmp_frame = data.frame(item = .y, set_chr = paste(set, collapse = \",\"), stringsAsFactors = FALSE)\n      tmp_frame$set = list(set)\n      tmp_frame\n    })\n  matched_list = split(mapped_data, mapped_data$set_chr)\n}\n```\n:::\n\n\nNot only is the code cleaner, the grouping is explicit (as long as you know **how** `split` works), and its also 4x faster!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmicrobenchmark::microbenchmark(\n  loop_function(mapped_items),\n  split_function(mapped_items),\n  times = 5\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUnit: seconds\n                         expr       min        lq      mean    median        uq\n  loop_function(mapped_items) 10.672729 10.694685 10.914005 10.872513 10.984026\n split_function(mapped_items)  3.011281  3.013769  3.082842  3.089458  3.131173\n      max neval\n 11.34607     5\n  3.16853     5\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}