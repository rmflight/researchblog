{
  "hash": "f463985e2e1696239d31e710b5be1162",
  "result": {
    "markdown": "---\ntitle: \"Creating a Map of Routes Weighted by Travel\"\nsubtitle: |\n  I made a map of my spouse's travel since we got Google phones for her birthday last fall. Here's how I did it.\ndate: 03-21-2021\ncategories: [graphing, maps, visualization]\nbibliography: refs.bib\n---\n\n\n## Inspiration\n\nWay back in October 2020, I saw a tweet cross my feed by Esteban on making personal map art, and I was struck by their map [@estebanmap2020].\nI was also looking for an idea for my spouses birthday that was coming up in November, and I decided to do one of these maps for my lovely wife.\n\nIf you want to create one of these, you should definitely check out Esteban's post [@estebanmap2020] for how they did it.\nEsteban also has figures for how things look as they go together.\nI'm not that organized, unfortunately.\n\nI'm detailing my process here, because I tried to organize it in a bit of a different way, putting as much stuff into functions as I could so I can reuse code where possible.\n\nYou can check out the code on GitHub [@rmflightmap2020] and see how it's organized.\n\nA short list of what you need for this project:\n\n* A region of interest with mapped roads in OpenStreetMap\n* A list of starting locations and ending locations that the shortest route is easily findable.\n  * Esteban and I used Google Maps takeout data.\n  * My spouse and I have location data from when we started using Google phones back in August of 2016.\n\n## Decide on a Size\n\nIdeally before embarking on this project, decide what size of a print you want.\nIf you are in the USA, WalMart's prices are actually pretty decent, and I've found their quality to be good.\nI was very happy with the canvas I got from them back in November.\nThe size of the print defines the ratio of the bounding box you are going to want to use and how you want it to look.\nI ultimately decided on a 16 in high by 20 in wide.\n\n## Find Your Bounding Box\n\nThis is the part that takes some interactive work unless you just want to work within a particular city limits.\n\nI used the export function on OpenStreetMap to create my bounding box of the area I was interested in.\n\nI used {drake} to define a workflow for this project so any fetching of data from OpenStreetMap would only have to be done once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthe_plan <-\n  drake_plan(\n    lexington_bbx = list(min_lon = -84.7533,\n                         max_lon = -84.2143,\n                         min_lat = 37.9358,\n                         max_lat = 38.1775),\n\n    lexington_map = get_map(lexington_bbx),\n    lexington_counties = get_counties(lexington_bbx, \"KY\"),\n    lexington_water = get_us_water(lexington_bbx,\n                                   lexington_counties,\n                                   \"KY\"),\n    lexington_counties_water = combine_counties_uswater(lexington_counties, lexington_water),\n    sarah_locations = get_takeout_locations(\"saraheflight/saraheflight_takeout\"),\n    sarah_routes = get_sarah_routes(sarah_locations)\n)\n```\n:::\n\n\nThis plan has the bounding box defined, fetches the map data, counties data, and any water data, merges it together, and then grabs the locations, and determines the routes.\n\n## Fetching Map\n\nWe fetch the map data for the bounding box.\nNote that we fetch a ton of the road data, because that is what is likely to make it look nice.\nWe also classify the highways and streets so that they can have a different weight in the final map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_map = function(bbx_list){\n  bbx = rbind(x=c(bbx_list$min_lon, bbx_list$max_lon),y=c(bbx_list$min_lat, bbx_list$max_lat))\n  colnames(bbx) = c(\"min\",\"max\")\n\n  highways = bbx %>%\n    opq() %>%\n    add_osm_feature(key = \"highway\",\n                    value=c(\"motorway\", \"trunk\",\n                            \"primary\",\"secondary\",\n                            \"tertiary\",\"motorway_link\",\n                            \"trunk_link\",\"primary_link\",\n                            \"secondary_link\",\n                            \"tertiary_link\")) %>%\n    osmdata_sf()\n  streets = bbx %>%\n    opq() %>%\n    add_osm_feature(key = \"highway\",\n                    value = c(\"residential\", \"living_street\",\n                              \"service\",\"unclassified\",\n                              \"pedestrian\", \"footway\",\n                              \"track\",\"path\")) %>%\n    osmdata_sf()\n\n  list(highways = highways,\n       streets = streets)\n}\n```\n:::\n\n\n## Adding County / State Features & Water\n\nWe also want to have the data for the county and waterways (there are probably lakes and rivers or coastlines near you).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_counties = function(bbx_list, state = \"KY\"){\n\n  counties_state = counties(state=state, cb=T, class=\"sf\")\n  counties_state = st_crop(counties_state,\n                         xmin = bbx_list$min_lon, xmax = bbx_list$max_lon,\n                         ymin = bbx_list$min_lat, ymax = bbx_list$max_lat)\n  counties_state\n}\n\nget_us_water = function(bbx_list, counties_list, state){\n  get_water = function(county_GEOID, state = state){\n    area_water(state, county_GEOID, class = \"sf\")\n  }\n  water = do.call(rbind,\n                   lapply(counties_list$COUNTYFP, get_water, state))\n  water = st_crop(water,\n                   xmin = bbx_list$min_lon, xmax = bbx_list$max_lon,\n                   ymin = bbx_list$min_lat, ymax = bbx_list$max_lat)\n  water\n}\n\ncombine_counties_uswater = function(counties_state, counties_water){\n  st_difference(counties_state, st_union(counties_water))\n}\n```\n:::\n\n\nThis gives us a decent image with the highways, streets, county level features, and the waterways.\n\n## Location Data\n\nAs I said previously, I used the Google Maps location data from Google Takeout.\nI asked my spouse for the data.\nBe advised, it can take Google a little bit to prepare this data depending on how much there is.\n\nIf you didn't have an automated source of data, you could probably set up a set of **destinations** replicated by how often you think you traveled there to get relative weights.\n\nFor this, we will parse through the takeout data and get all of the destinations.\n\nThe function below goes through all of the files (they are organized by year and month) and grabs the locations, and puts them into a data.frame to iterate through.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_takeout_locations = function(takeout_dir){\n\n  file2 = file.path(takeout_dir, \"Takeout\", \"Location History\", \"Semantic Location History\")\n  files = list.files(file2, pattern = \"*.json\", recursive = TRUE, full.names = TRUE)\n  get_locations = function(file, .progress = NULL){\n    knitrProgressBar::update_progress(.progress)\n    data = jsonlite::fromJSON(file)\n    tl_obj = data$timelineObjects$placeVisit\n    loc = cbind(tl_obj$location, tl_obj$duration)\n    tt = as.numeric(loc$startTimestampMs)/1000\n    loc$time=as.POSIXct(tt,origin = \"1970-01-01\")\n    #conver longitude & latitude from E7 to GPS\n    loc$lat = loc$latitudeE7 / 1e7\n    loc$lon = loc$longitudeE7 / 1e7\n    loc = data.frame(loc)\n    loc = loc[, c(\"placeId\", \"time\", \"lat\", \"lon\")]\n    loc = dplyr::filter(loc, !is.na(lon))\n    loc\n  }\n  locs_df = purrr::map_df(files, get_locations)\n  locs_df\n}\n```\n:::\n\n\n## Routes\n\nThen we have to work out the routes.\nFor this project, it was complicated by the fact that we've lived in two different locations since we moved here.\nSo this function sets two different home locations, and switches between them depending on the date of the trip.\n\nWe also assume that every trip is a trip between **home** and the **destination**.\nThe locations are organized by day, so we have to do some transformations to make every trip start at **home** and end at the **destination**.\nObviously that's not how we actually travel, but otherwise I'd have to try and extract the route level data from the takeout, and that would be more of a pain.\nAnd for the kind of map we are trying to generate, this works well enough.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_sarah_routes = function(locs_df){\n  old_home = list(lat = 37.9898308, lon = -84.5054868)\n  new_home = list(lat = 37.982469, lon = -84.506552)\n  locs_df$day = lubridate::floor_date(locs_df$time, unit = \"day\")\n  locs_df = tibble::as_tibble(locs_df)\n  locs_df = dplyr::mutate(locs_df, home = dplyr::case_when(\n    day <= as.POSIXct(\"2018-03-14\") ~ list(old_home),\n    TRUE ~ list(new_home)\n  ))\n\n  split_day = split(locs_df, locs_df$day)\n\n  day_routes = purrr::map(split_day, daily_routes)\n  day_routes = do.call(rbind, day_routes)\n}\n\ndaily_routes = function(day_locations){\n  home_loc = day_locations$home[[1]]\n  use_locs = day_locations[, c(\"lat\", \"lon\")]\n  use_locs2 = rbind(data.frame(lat = home_loc$lat, lon = home_loc$lon),\n                    use_locs,\n                    data.frame(lat = home_loc$lat, lon = home_loc$lon))\n  route = NULL\n  for(irow in 2:nrow(use_locs2)){\n    p1 = c(use_locs2$lon[irow - 1], use_locs2$lat[irow - 1])\n    p2 = c(use_locs2$lon[irow], use_locs2$lat[irow])\n    oo = osrmRoute(src = p1, dst = p2, returnclass = \"sf\",\n                    overview = \"full\")\n    route <- rbind(route, oo)\n  }\n  route\n}\n```\n:::\n\n\n## Plot It!\n\nFinally, we put everything together into an image that can be plotted!\n\nThis ended up in a script because I was doing a lot of playing around with it, and when I finally got the image, I just saved the final script.\nYou can also see here that after the fact I was trying to mess with the bounding box to get the correct aspect ratio.\nDon't be like me, do it up front and figure it out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"packages.R\")\nloadd(lexington_bbx)\nloadd(lexington_map)\nnames(lexington_map)\nloadd(lexington_counties_water)\nloadd(sarah_routes)\n\nlexington_bbx = list(min_lon = -84.7533,\n                     max_lon = -84.355,\n                     min_lat = 37.9358,\n                     max_lat = 38.1775)\n\n(lexington_bbx$max_lat - lexington_bbx$min_lat) / (lexington_bbx$max_lon - lexington_bbx$min_lon)\n\ncolor_roads <- rgb(0.42,0.449,0.488)\nfinal_map = ggplot() +\n  geom_sf(data = lexington_counties_water,\n          inherit.aes = FALSE,\n          lwd= 0.0, fill = rgb(0.203,0.234,0.277)) +\n  geom_sf(data = lexington_map$streets$osm_lines,\n          inherit.aes = FALSE,\n          color=color_roads,\n          size = .4,\n          alpha = .65) +\n  geom_sf(data = lexington_map$highways$osm_lines,\n          inherit.aes = FALSE,\n          color=color_roads,\n          size = .6,\n          alpha = .65) +\n  geom_sf(data = st_geometry(sarah_routes),\n          inherit.aes = FALSE, col = \"orange\", alpha = 0.2) +\n  coord_sf(xlim = c(lexington_bbx$min_lon, lexington_bbx$max_lon),\n           ylim = c(lexington_bbx$min_lat, lexington_bbx$max_lat),\n           expand = FALSE) +\n  theme(legend.position = \"none\") + theme_void() +\n  theme(panel.background=\n          element_rect(fill = \"white\"))\n\nggsave(final_map,\n       filename = \"sarah_lexington.png\",\n       scale = 1,\n       width = 20,\n       height = 16,\n       units = \"in\",\n       bg = rgb(0.203,0.234,0.277),\n       dpi = 500)\n```\n:::\n\n\n\nAnd what I got was this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](sarah_lexington.png){width=5000}\n:::\n:::\n\n\nAnd now it hangs on our wall as a canvas print:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](IMG_20210321_215455.jpg)\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}