{
  "hash": "31e70f0a4ccf48fe5dc32aa6003ea110",
  "result": {
    "markdown": "---\ntitle: \"Using IRanges for Non-Integer Overlaps\"\ndate: '2018-06-23'\ncategories: [R, iranges, development, programming]\nsubtitle: |\n  I wanted to make use of IRanges awesome interval logic, but for non-integer data.\n---\n\n\n## TL;DR\n\nThe [`IRanges`](https://bioconductor.org/packages/IRanges/) package implements interval algebra, and is very fast for finding overlaps of two ranges. If you have non-integer data, multiply values by a **large** constant factor and round them. The constant depends on how much accuracy you need.\n\n## IRanges??\n\n[`IRanges`](https://bioconductor.org/packages/IRanges/) is a bioconductor package for interval algebra of **i**nteger **ranges**. It is used extensively in the `GenomicRanges` package for finding overlaps between various genomic features. For genomic features, **integers** make sense, because one cannot have fractional base locations.\n\nHowever, `IRanges` uses [red-black trees](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) as its data structure, which provide very fast searches of overlaps. This makes it very attractive for **any** problem that involves overlapping ranges.\n\n## Motivation\n\nMy motivation comes from mass-spectrometry data, where I want to count the number of raw data points and / or the number of peaks in a **large** number of M/Z windows. Large here means on the order of 1,000,000 M/Z windows.\n\nGenerating the windows is not hard, but searching the list of points / peaks for which ones are within the bounds of a window takes **a really long time**. Long enough that I needed some other method.\n\n## IRanges to the Rescue!\n\nSo my idea was to use `IRanges`. But there is a problem, `IRanges` is for integer ranges. How do we use this for non-integer data? Simple, multiply and round the fractional numbers to generate integers.\n\nIt turns out that multiplying our mass-spec data by `20,000` gives us differences down to the `0.00005` place, which is more than enough accuracy for the size of the windows we are interested in. If needed, `IRanges` can handle `1600 * 1e6`, but currently will crash at `1600 * 1e7`.\n\n## How Fast Is It?\n\nLets actually test differences in speed by counting how many overlapping points there are.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(IRanges)\nlibrary(ggplot2)\nload(here::here(\"data_files/iranges_example_data.rda\"))\n\nhead(mz_points)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 6 ranges and 1 metadata column:\n          start       end     width |        mz\n      <integer> <integer> <integer> | <numeric>\n  [1]   2970182   2970182         1 |   148.509\n  [2]   2970183   2970183         1 |   148.509\n  [3]   2970184   2970184         1 |   148.509\n  [4]   2970186   2970186         1 |   148.509\n  [5]   3000526   3000526         1 |   150.026\n  [6]   3000527   3000527         1 |   150.026\n```\n:::\n\n```{.r .cell-code}\nhead(mz_windows)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIRanges object with 6 ranges and 2 metadata columns:\n          start       end     width |  mz_start    mz_end\n      <integer> <integer> <integer> | <numeric> <numeric>\n  [1]   2960000   2960011        12 |       148   148.001\n  [2]   2960001   2960012        12 |       148   148.001\n  [3]   2960002   2960013        12 |       148   148.001\n  [4]   2960003   2960014        12 |       148   148.001\n  [5]   2960004   2960016        13 |       148   148.001\n  [6]   2960006   2960017        12 |       148   148.001\n```\n:::\n:::\n\n\nI have some [example data](https://github.com/rmflight/researchBlog_blogdown/blob/master/data/iranges_example_data.rda) with 3447542 windows, and 991816 points. We will count how many point there are in each window using the below functions, with differing number of windows.\n\n### Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_overlaps_naive <- function(mz_start, mz_end, points){\n  sum((points >= mz_start) & (points <= mz_end))\n}\n\niterate_windows <- function(windows, points){\n  purrr::pmap_int(windows, count_overlaps_naive, points)\n}\n\nrun_times_iterating <- function(windows, points){\n  t <- Sys.time()\n  window_counts <- iterate_windows(windows, points)\n  t2 <- Sys.time()\n  run_time <- difftime(t2, t, units = \"secs\")\n  run_time\n}\n\nrun_times_countoverlaps <- function(windows, points){\n  t <- Sys.time()\n  window_counts <- countOverlaps(points, windows)\n  t2 <- Sys.time()\n  run_time <- difftime(t2, t, units = \"secs\")\n  run_time\n}\n```\n:::\n\n\n### Define Samples of Different Sizes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\n\nsample_sizes <- c(10, 100, 1000, 10000, 50000, 100000)\n\nwindow_samples <- purrr::map(sample_sizes, function(x){sample(length(mz_windows), size = x)})\n```\n:::\n\n\n### Run It\n\n\n::: {.cell}\n\n```{.r .cell-code}\niranges_times <- purrr::map_dbl(window_samples, function(x){\n  run_times_countoverlaps(mz_windows[x], mz_points)\n})\n\nwindow_frame <- as.data.frame(mcols(mz_windows))\n\nnaive_times <- purrr::map_dbl(window_samples, function(x){\n  run_times_iterating(window_frame[x, ], mz_points)\n})\n```\n:::\n\n\n### Plot Them\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_times <- data.frame(size = rep(sample_sizes, 2),\n                        time = c(iranges_times, naive_times),\n                        method = rep(c(\"iranges\", \"naive\"), each = 6))\n\np <- ggplot(all_times, aes(x = log10(size), y = time, color = method)) + geom_point() + geom_line() + labs(y = \"time (s)\", x = \"log10(# of windows)\", title = \"Naive & IRanges Timings\") + theme(legend.position = c(0.2, 0.8))\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/difference_times-1.svg){width=672}\n:::\n\n```{.r .cell-code}\np + coord_cartesian(ylim = c(0, 1))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/difference_times-2.svg){width=672}\n:::\n:::\n\n\nAs the two figures show, the naive solution, while a little faster under 1000 regions, is quickly outperformed by `IRanges`, whose time increases much more slowly.\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}