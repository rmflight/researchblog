{
  "hash": "28472974f48aef8e82b8b73632bcdd3f",
  "result": {
    "markdown": "---\ntitle: \"Using group_by Instead of Splits\"\ndate: '2020-02-25'\ncategories: [R, dplyr, split, group-by, programming, development]\nsubtitle: |\n  How to use group_by instead of split's to summarize things.\n---\n\n\n\n## TL;DR\n\nIt is relatively easy to use `dplyr::group_by` and `summarise` to find items that you might want to keep or remove based on a **part_of** the item or group in question. I used to use `split` and iterate, but `group_by` is much easier.\n\n## Motivation\n\nI have some relatively large sets of data that fall naturally into groups of items.\nOften, I find that I want to remove a group that contains either **any of** or **all of** particular items. Let's create some data as an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nset.seed(1234)\ngroups = as.character(seq(1, 1000))\ngrouped_data = data.frame(items = sample(letters, 10000, replace = TRUE),\n                          groups = sample(groups, 10000, replace = TRUE),\n                          stringsAsFactors = FALSE)\n\nknitr::kable(head(grouped_data))\n```\n\n::: {.cell-output-display}\n|items |groups |\n|:-----|:------|\n|p     |891    |\n|z     |646    |\n|v     |795    |\n|e     |49     |\n|l     |19     |\n|o     |796    |\n:::\n:::\n\n\nIn this example, we have the 26 lowercase letters, that are part of one of groups 1-1000.\nNow, we might want to keep any groups that contain at least one \"a\", for example.\n\nI would have previously used a `split` on the groups, and then `purrr::map_lgl` returning TRUE or FALSE to check if what we wanted to filter on was present, and then filter out the split groups, and finally put back together the full thing.\n\n## Group By\n\nWhat I've found instead is that I can use a combination of `group_by`, `summarise` and then `filter` to same effect, without splitting and iterating (yes, I know `dplyr` is doing it under the hood for me).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use group_by and summarize to find things we want\ngroups_to_keep = grouped_data %>% \n  group_by(groups) %>%\n  summarise(has_a = sum(items %in% \"a\") > 0) %>%\n  filter(has_a)\n\n# filter on original based on above\ngrouped_data2 = grouped_data %>%\n  filter(groups %in% groups_to_keep$groups)\n```\n:::\n\n\nThis was a game changer for me in my thinking. As I've used `group_by` combined with `summarise` more and more, I've become amazed at what can be done without having to fully split the data apart to operate on it. \n\nThis combined with the use of `dplyr::join_` in place of splits (see [this other post](http://rmflight.github.io/post/split-unsplit-anti-pattern/) for an example) is making my code faster, and often easier to reason over. I hope it helps you too!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}